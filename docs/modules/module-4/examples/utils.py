"""
Utility functions for Vision-Language-Action (VLA) Module examples
"""

import json
import logging
import os
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class VoiceCommand:
    """
    Data class representing a voice command with its metadata
    """
    id: str
    text: str
    timestamp: datetime
    confidence: float
    context: Dict[str, Any]


@dataclass
class Action:
    """
    Data class representing a robot action
    """
    id: str
    type: str  # navigation, manipulation, perception, communication
    parameters: Dict[str, Any]
    priority: int
    timeout: int  # seconds


@dataclass
class ActionSequence:
    """
    Data class representing an ordered sequence of robot actions
    """
    id: str
    steps: List[Action]
    status: str  # pending, executing, completed, failed
    created_at: datetime
    robot_id: str


@dataclass
class LLMPlan:
    """
    Data class representing a plan generated by a Large Language Model
    """
    id: str
    goal: str
    plan: List[Dict[str, Any]]
    confidence: float
    generated_at: datetime


def load_api_key(api_key_name: str = "OPENAI_API_KEY") -> Optional[str]:
    """
    Load API key from environment variable or .env file

    Args:
        api_key_name: Name of the environment variable containing the API key

    Returns:
        API key string if found, None otherwise
    """
    try:
        # Try to load from environment
        api_key = os.getenv(api_key_name)
        if api_key:
            return api_key

        # Try to load from .env file
        from dotenv import load_dotenv
        load_dotenv()
        return os.getenv(api_key_name)
    except ImportError:
        logger.warning("python-dotenv not installed, skipping .env file loading")
        return os.getenv(api_key_name)
    except Exception as e:
        logger.error(f"Error loading API key: {e}")
        return None


def validate_voice_command(command: VoiceCommand, min_confidence: float = 0.7) -> bool:
    """
    Validate a voice command based on confidence and other criteria

    Args:
        command: VoiceCommand object to validate
        min_confidence: Minimum confidence threshold

    Returns:
        True if command is valid, False otherwise
    """
    if not command.text.strip():
        logger.warning("Voice command has empty text")
        return False

    if command.confidence < min_confidence:
        logger.warning(f"Voice command confidence {command.confidence} below threshold {min_confidence}")
        return False

    return True


def validate_action(action: Action) -> bool:
    """
    Validate an action based on required fields

    Args:
        action: Action object to validate

    Returns:
        True if action is valid, False otherwise
    """
    valid_types = ["navigation", "manipulation", "perception", "communication"]

    if action.type not in valid_types:
        logger.warning(f"Invalid action type: {action.type}")
        return False

    if not isinstance(action.parameters, dict):
        logger.warning("Action parameters must be a dictionary")
        return False

    if action.priority < 0:
        logger.warning("Action priority should be non-negative")
        return False

    if action.timeout <= 0:
        logger.warning("Action timeout should be positive")
        return False

    return True


def validate_action_sequence(sequence: ActionSequence) -> bool:
    """
    Validate an action sequence

    Args:
        sequence: ActionSequence object to validate

    Returns:
        True if sequence is valid, False otherwise
    """
    if not sequence.id:
        logger.warning("Action sequence must have an ID")
        return False

    if not sequence.steps:
        logger.warning("Action sequence must have at least one step")
        return False

    for action in sequence.steps:
        if not validate_action(action):
            return False

    valid_statuses = ["pending", "executing", "completed", "failed"]
    if sequence.status not in valid_statuses:
        logger.warning(f"Invalid action sequence status: {sequence.status}")
        return False

    return True


def safe_execute_with_timeout(func, timeout: int, *args, **kwargs) -> Any:
    """
    Execute a function with a timeout

    Args:
        func: Function to execute
        timeout: Timeout in seconds
        *args, **kwargs: Arguments to pass to the function

    Returns:
        Result of the function if it completes in time, None otherwise
    """
    import signal

    class TimeoutError(Exception):
        pass

    def timeout_handler(signum, frame):
        raise TimeoutError("Function execution timed out")

    # Set up the timeout
    old_handler = signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)

    try:
        result = func(*args, **kwargs)
        signal.alarm(0)  # Cancel the alarm
        return result
    except TimeoutError:
        logger.warning(f"Function timed out after {timeout} seconds")
        return None
    finally:
        signal.signal(signal.SIGALRM, old_handler)


def format_action_for_ros2(action: Action) -> Dict[str, Any]:
    """
    Format an action for ROS 2 communication

    Args:
        action: Action object to format

    Returns:
        Dictionary formatted for ROS 2 action message
    """
    return {
        "action_type": action.type,
        "parameters": action.parameters,
        "priority": action.priority,
        "timeout": action.timeout,
        "timestamp": action.timestamp.isoformat() if hasattr(action, 'timestamp') else datetime.now().isoformat()
    }


def log_vla_event(event_type: str, message: str, level: str = "INFO"):
    """
    Log a VLA system event

    Args:
        event_type: Type of event (e.g., "voice_recognition", "llm_planning", "action_execution")
        message: Event message
        level: Log level ("DEBUG", "INFO", "WARNING", "ERROR")
    """
    log_levels = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR
    }

    logger.log(log_levels.get(level, logging.INFO), f"[{event_type}] {message}")


def calculate_plan_confidence(plan: LLMPlan) -> float:
    """
    Calculate an overall confidence score for an LLM plan

    Args:
        plan: LLMPlan object

    Returns:
        Confidence score between 0 and 1
    """
    # Base confidence from LLM
    confidence = plan.confidence

    # Adjust based on plan complexity
    if len(plan.plan) > 10:  # Complex plan
        confidence *= 0.9
    elif len(plan.plan) > 5:  # Moderate plan
        confidence *= 0.95

    # Ensure confidence is within bounds
    return max(0.0, min(1.0, confidence))


def sanitize_text_input(text: str) -> str:
    """
    Sanitize text input for security and safety

    Args:
        text: Input text to sanitize

    Returns:
        Sanitized text
    """
    # Remove potentially dangerous characters/sequences
    sanitized = text.strip()

    # Remove command injection patterns
    dangerous_patterns = [";", "&&", "||", "|", "&", "$", "`", ">", "<"]
    for pattern in dangerous_patterns:
        sanitized = sanitized.replace(pattern, "")

    return sanitized


# Example usage and testing
if __name__ == "__main__":
    # Test the utility functions
    print("Testing VLA utilities...")

    # Test voice command validation
    test_command = VoiceCommand(
        id="test_001",
        text="Move forward",
        timestamp=datetime.now(),
        confidence=0.85,
        context={}
    )

    is_valid = validate_voice_command(test_command)
    print(f"Voice command validation: {is_valid}")

    # Test action validation
    test_action = Action(
        id="action_001",
        type="navigation",
        parameters={"x": 1.0, "y": 2.0},
        priority=1,
        timeout=30
    )

    is_valid = validate_action(test_action)
    print(f"Action validation: {is_valid}")

    print("VLA utilities test completed.")